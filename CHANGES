22 May 2012, Dmitriy Selyutin
All the class variables of the GNULibImport class which must store relative
paths now REALLY will store relative paths. They also set these relative paths
through couple of set* methods. I wanted to do it a long time ago. All these
set* methods become a bit shorter after removing of two unuseful lines.
Some necessary changes inside places where local files must be read to get some
variables (I mean configure.ac/in and Makefile.am).
Some good changes were also done inside methods of the GNULibImport class. For
example, reset* methods now simply get the default values from cache. I think
this is the best way to get default values. As you may see some variables now
have two values: the one is an attribute (self._sourcebase_) and the other is a
cached value inside self._cached_ dictionary.
About one half of heuristics needed to get m4base for other modes was done. New
compiler and cleaner functions were added to constants.py to do all the similar
actions at all results of the search. They were tested at GNU Hello (I had to
craete some files like aclocal.m4, m4/gnulib-cache.m4, however).
New compiler and cleaner functions were added to constants.py to do all the
similar actions at all results of the search.

18 May 2012, Dmitriy Selyutin
GNULibError class was created to handle all errors which are specific for
pygnulib module. The first error ('no configure file was found') already was
added; there will be much more errors in the future.
The key 'verbose-default' was added to MODES list to store default value for
verbose. So when user is going to write his own script based on pygnulib, he
can import constants.py and use values from this module. This is something like
how the most part of users use QtCore module from PyQt4 package. New keys for
different modes were added: 'import', 'add-import', 'remove-import', 'update'.
GNULibImport now has its own attribute self.mode, which is not hidden like
other attributes, but is left to represent current mode. This is necessary
attribute, so user has to set it when he creates new GNULibImport instance.
Mode can be integer from 0 to 3. You can get all the modes from constants.py:
>>> from pygnulib import constants
>>> from pygnulib import utilities
>>> MODES = constants.MODES
>>> obj_import = utilities.GNULibImport(MODES['import'])
>>> obj_add_import = utilities.GNULibImport(MODES['add-import'])
>>> obj_remove_import = utilities.GNULibImport(MODES['remove-import'])
>>> obj_update = utilities.GNULibImport(MODES['update'])
Now almost all attributes inside __init__ part of GNULibImport are set using
GNULibImport methods. This way allows to delete a lot of puplicated code and
definitely helps maintainability. I think that the size of the GNULibImport was
decreased by one third.
New method for getting cached values from configure.ac/configure.in and
gnulib-cache.m4 files was added to GNULibImport section. Now all the values are
set from their cached version by default.
PYTHON3 constant was added to constants.py to contain boolean value if Python 3
is used. That was done to add re.UNICODE flag for Python 2 and don't delete it
for Python 3; it can be also useful in the future.

16 May 2012, Dmitriy Selyutin
Some small changes were added to GNULibImport class. New method copyright_notice
was added to GNULibInfo module. Now working on how to get cached values.

10 May 2012, Dmitriy Selyutin
New getAvailableModules method was added to GNULibMode class. This method will
return a tuple which contains lists of modules. I've used the original code,
because find command works much faster than usual cycle. However I've added
to testing.py a new function which tests list which can be gotten with the list
which user get after running original gnulib-tool with --list version.
ENCS['shell'] returned None value if user redirected stdout to file. That gave
an error where we used subprocess module to get stdout and then converted
stdout to string type. That gave a decode error, because there is no encoding
which has None type. Now if shell redirects output the console encoding is
'UTF-8'. I need to test this behaviour under different platforms, however.
Functions from testing.py were renamed to use unique names.
I've also added modules directory, because it allows to use getAvailableModules
function. However, you have to place pygnulib and gnulib-tool.py to directory
where old gnulib-tool is placed to make testVersion work. All other functions
will work without moving to another directory.

8 May 2012, Dmitriy Selyutin
A lot of methods inside GNULibMode and GNULibImport classes were rewritten to
handle different errors (first of all to catch errors when user sets wrong type
of value to attribute). Almost all attributes have got their default values
(for example, self._destdir_ now has value of current dir, if it was not set by
user); you can see full a full list of the default values by running:
>>> from pygnulib import utilities
>>> help(utilities.GNULibImport)
That also means that now you can set almost all initial attributes immediately
when you create a new class instance. This is a very good change, because you
can just set some parameters from the __init__ and don't have to touch the
other parameters. That requires only one string in script, so it can save a lot
of time. For example compare these two scripts:
>>> # Old style
>>> importobj = utilities.GNULibImport()
>>> importobj.setDestDir('/new/directory')
>>> importobj.enableDryRun()
>>> # New style
>>> importobj = utilities.GNULibImport(destdir='/new/directory', dryrun=True)
New key was added to DIRS variable to store current directory when pygnulib was
called. To get current working directory without problems with unicode/str,
type DIRS['cwd']. This DIRS variable will be used later to calculate relative
pathname easy; I think there is a lot of other situations where it can be
useful, so I think this is one of the most necessary variables.

7 May 2012, Dmitriy Selyutin
Support for bytes and string types was improved: some source code was added to
check what type variables have from the beginning (bytes or unicode/str). That
was done to provide support for Python 2. unicode_literals function doesn't
provide support for sys.argv and most of os.path functions, which return
bytes type in Python 2, while some system (first of all Windows) need unicode
strings for filenames. However, we have to check only basic filenames, because
all other functions return type basing on input type (i.e. if function gets
bytes type, it will return bytes type, otherwise it will return unicode in
Python 2). This is necessary only in Python 2, but I think we need to support
Python 2 at least at first stages. The most common way is to check a string if
it has bytes type; if yes, convert it to string type, which is equal to unicode
type for Python 2 and to str type for Python 3. Maybe in future I'll create a
class for this purpose. I know this may be overkilling, but I hope to provide
full support for people who still use Python 2.
To look at pretty handling for string type, you can run several commands inside
Python's interperter (you must run it from directory where gnulib-tool.py is
placed):
>>> from pygnulib import constants
>>> from pprint import pprint
>>> pprint(constants.__dict__)
As you can see all the variables which are needed by gnulib-tool now have
unicode or str type depending on current Python version. Some methods that
touch encodings were changed, too (now they depend on ENCS['system'] variable).
Section where global variables are deleted from constants.py was removed.
Method setDestDir, which was inherited from GNULibMode class, was added to
GNULibImport class to update _*base_ variables after _destdir_ variable was
set. To make it easy, it uses super function to operate with the parent class.
GNULibMode now inherits from object type to make super function work.
Several methods were added to GNULibImport class. I'm going to make this class
immutable just to prevent a situation like GNULibImport._destdir_ = 'strange
value for variable _destdir_ may cause errors!'.
Methods addImport, removeImport, setImports, getImports inside GNULibImport
class were renamed to addModule, removeModule, setModules, getModules not to
confuse users. Description of these methods was changed, too. The name of the
self._imports_ variable was changed to self._modules_.
A lot of methods was added to GNULibImport class.
The sequence of actions with GNULibImport class will be represented in the
following way:
  1. User creates GNULibImport class, defines modules which will be used in
--import, --add-import, --remove-import actions, sets options and variables.
  2. User runs functions which correspond to --import, --add-import,
--remove-import actions and they get all the necessary information from
GNULibImport class.

5 May 2012, Dmitriy Selyutin
Some new methods were added to GNULibImport. Check for '\r' as endline marker
in the testing section was deleted, because no system exists which supports
this type on endline.

4 May 2012, Dmitriy Selyutin
New module testing.py was added to compare gnulib-tool.sh and gnulib-tool.py.
At this time there are two functions: version and help, which compares outputs
after running gnulib-tool with --version or --help argument respectively. All
the difference between outputs is printed using difflib module. If outputs were
exactly the same, test was completed successfully. In the future there will be
much more functions, so they will be combined into classes (e.g. one class to
test --add-import mode with different modules, other to test a --list mode,
third to test --remove-import with different modules, etc.).
GNULibInfo class received new method, help, which allows to get help message
like if you execute gnulib-tool with --help parameter. I think I'll leave it,
because it is hard (if even possible) to make argparse print exactly the same.
Some methods were added to GNULibImport module.

3 May 2012, Dmitriy Selyutin
GNULibMode functionality was reimplemented and redone from zero. Now GNULibMode
is the parent for all the other modes, and the first one is GNULibImport class,
which is used to provide methods for --import, --add-import, --remove-import
and --update actions. New constant MODES was added to constants.py to handle
types of tests and minimal/maximal value for verbosity level. It seems that
there will be much more constants in this section in the future.

2 May 2012, Dmitriy Selyutin
The delevelopment of GNULibMode has started. I think I'll separate this module
in the future, but the main concept will remain unchanged. Just to let you know
that development still continues.

1 May 2012, Dmitriy Selyutin
Paul Eggert was added to the list of authors (see __author__ variable). Method
date from GNULibInfo was commented to help developers understand how the date
is calculated. Module is now separated for better maintainability. Instead of
single gnulib-tool.py you get pygnulib package and two modules: constants.py
and utilities.py.
constants module now contains all date which user or developers can change (e.g.
paths for automake, autoconf utilities, authors, application name, etc.). To 
understand how to use constants look inside the utilities.py module (see 'Define
module information' and 'Define global constants' sections). All the future
parts of pygnulib module will use the same model to define constants.
utilities module now contains GNULibInfo class. I think the most part of classes
will be placed here; however some modules can be separated in the future.

30 Apr 2012, Dmitriy Selyutin
Just a small fix with strings to obtain backward-compatibility with Python 2
from Python 3. Now you can either run (python2 gnulib-tool.py) or (python3
gnulib-tool.py). I remind that you must copy gnulib-tool.py file to directory
with the original gnulib-tool.

28 Apr 2012, Dmitriy Selyutin
New variable was added, called FILES. It is a dictionary like DIRS variable,
but it will store some paths to necessary files. The first such file is
ChangeLog file, which is used in (git log ChangeLog) command. Two new methods
were added to GNULibInfo class: date and version (the last one is now available
only for git, I will add support for CVS later). Note that name method inside
GNULibInfo class was renamed to package, because it's more correct. If you type
(python gnulib.py), you will receive the same output as from (gnulib-tool
--version) command (however the first line will say that name of application is
gnulib-tool.py until you rename it). However to test this feature you have to
place new gnulib-tool in folder where the old one is placed.
I've also added two new files to root: architecture.odg and functions.odt just
to have their copies. However it may be useful to have these files online.

27 Apr 2012, Dmitriy Selyutin
APPS variable is now called UTILS. Some variables like __appname__, __appath__
and __appdir__ were replaced to global APP dictionary, which now contains args
'name' and 'path'. New global variable DIRS was created to store full paths of
the main directory and subdirectories. New GNULibInfo class was created; it
contains some useful methods like name, authors, license and copyright. Don't be
confused with some similar variables like __author__, __license__, etc. The new
methods and variables are similar, but they are not the same: methods will
provide user information which will be mostly used in stdout messages. Later I
am going to add version method, which will extract versions of script and from
git (or CVS if we will use it in the future). You can see almost completed
stdout message which you can get from (gnulib-tool.sh --version). To see it
just run (python gnulib-tool.py).

26 Apr 2012, Dmitriy Selyutin
Some global variables were added. Variables that contain paths of necessary
applications (AUTOCONF, AUTORECONF, AUTOHEADER, AUTOMAKE, ACLOCAL, AUTOPOINT,
LIBTOOLIZE, MAKE) were combined into one dict object (APPS), so in the furure I
have to use e.g. APP['autoconf'] instead of AUTOCONF. I know that this style is
longer, but I think it is a good idea to combinate similar variables into
dictionaries and lists. While it seems that some variables (AUTOCONFPATH,
AUTOMAKEPATH, GETTEXTPATH and LIBTOOLPATH) won't be used later, I've decided to
delete them using del() statement to free memory and just to be consistent.